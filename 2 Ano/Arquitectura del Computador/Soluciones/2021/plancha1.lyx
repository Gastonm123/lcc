#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass ../../../../lyx
\use_default_options true
\begin_removed_modules
theorems-ams
theorems-chap
multicol
\end_removed_modules
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Cover

\end_layout

\begin_layout Standard
\begin_inset VSpace vfill*
\end_inset


\end_layout

\begin_layout Title
Plancha 1
\end_layout

\begin_layout Author
C y sistemas de numeración posicional
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill*
\end_inset


\end_layout

\begin_layout Date
2022 - Arquitectura del Computador
\end_layout

\begin_layout Date
Licenciatura en Ciencias de la Computación
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill*
\end_inset


\end_layout

\begin_layout Chapter
Introducción
\end_layout

\begin_layout Standard
Esta plancha trata los sistemas de representación de números enteros en
 el lenguaje de programación C y los operadores de bits para manipular estos
 números a bajo nivel.
\end_layout

\begin_layout Chapter
Procedimiento
\end_layout

\begin_layout Standard
Resuelva cada ejercicio en computadora.
 Cree un subdirectorio dedicado para cada ejercicio, que contenga todos
 los archivos del mismo.
 Para todo ejercicio que pida escribir código, genere un programa completo,
 con su función 
\family typewriter
main
\family default
 correspondiente; evite dejar fragmentos sueltos de programas.
\end_layout

\begin_layout Standard
Asegúrese de que todos los programas que escriba compilen correctamente
 con 
\family typewriter
gcc
\family default
.
 Se recomienda además pasar a este las opciones 
\family typewriter
-Wall
\family default
 y 
\family typewriter
-Wextra
\family default
 para habilitar advertencias sobre construcciones cuestionables en el código.
\end_layout

\begin_layout Chapter
Ejercicios
\end_layout

\begin_layout Enumerate
A continuación se presentan ciertos números enteros expresados en binario
 utilizando 32 bits y a su derecha, expresiones en lenguaje C incompletas.
 Complete estas expresiones de forma que la igualdad sea cierta.
 Utilice operadores de bits, operadores enteros y constantes de enteros
 literales según considere necesario.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

10000000 00000000 00000000 00000000 == ...
 << ...
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

10000000 00000000 10000000 00000000 == (1 << ...) | (1 << ...)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

11111111 11111111 11111111 00000000 == -1 & ...
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

10101010 00000000 00000000 10101010 == 0xAA ...
 (0xAA << ...)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

00000000 00000000 00000101 00000000 == 5 ...
 8
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

11111111 11111111 11111110 11111111 == -1 & (...
 (1 << 8))
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

11111111 11111111 11111111 11111111 == 0 ...
 1
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

00000000 00000000 00000000 00000000 == 0x80000000 + ............
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Soluciones
\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

10000000 00000000 00000000 00000000 == 1 << 31
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

10000000 00000000 10000000 00000000 == (1 << 31) | (1 << 15)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

11111111 11111111 11111111 00000000 == -1 & (-1 << 8)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

10101010 00000000 00000000 10101010 == 0xAA | (0xAA << 24)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

00000000 00000000 00000101 00000000 == 5 << 8
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

11111111 11111111 11111110 11111111 == -1 & (~ (1 << 8))
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

11111111 11111111 11111111 11111111 == 0 - 1
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

00000000 00000000 00000000 00000000 == 0x80000000 + 0x80000000
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Implemente una función 
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

int is_one(long n, int b);
\end_layout

\end_inset

 que indique si el bit 
\family typewriter
b
\family default
 del entero 
\family typewriter
n
\family default
 es 1 o 0.
\end_layout

\begin_deeper
\begin_layout Paragraph
Solución
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

int is_one(long n, int b) {
\end_layout

\begin_layout Plain Layout

    return n & (1 << b);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Implemente una función 
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

void printbin(unsigned long n);
\end_layout

\end_inset

 que tome un entero de 32 bits y lo imprima en binario.
\end_layout

\begin_deeper
\begin_layout Paragraph
Solución
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void printbin(unsigned long n) {
\end_layout

\begin_layout Plain Layout

    for (int i = 31; i >= 0; i--)
\end_layout

\begin_layout Plain Layout

        printf("%c", is_one(n, i) ? '1' : '0');
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Implemente una función que tome tres parámetros 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 y 
\begin_inset Formula $c$
\end_inset

 y que rote los valores de las variables de manera que al finalizar la función
 el valor de a se encuentre en 
\begin_inset Formula $b$
\end_inset

, el valor de 
\begin_inset Formula $b$
\end_inset

 en 
\begin_inset Formula $c$
\end_inset

 y el de 
\begin_inset Formula $c$
\end_inset

 en 
\begin_inset Formula $a$
\end_inset

.
 Evitar utilizar variables auxiliares.
 Ayuda: Tener en cuenta las propiedades del operador 
\family typewriter
XOR
\family default
.
\end_layout

\begin_deeper
\begin_layout Paragraph
Solución
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void swap(unsigned long* a, unsigned long* b, unsigned long* c) {
\end_layout

\begin_layout Plain Layout

    *a = *a ^ *b ^ *c;
\end_layout

\begin_layout Plain Layout

    *b = *a ^ *b ^ *c;
\end_layout

\begin_layout Plain Layout

    *c = *a ^ *b ^ *c;
\end_layout

\begin_layout Plain Layout

    *a = *a ^ *b ^ *c;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Escriba un programa que tome la entrada estándar, la codifique e imprima
 el resultado en salida estándar.
 La codificación deberá ser hecha carácter a carácter utilizando el operador
 
\family typewriter
XOR
\family default
 y un código que se pase al programa como argumento de línea de comando.
\end_layout

\begin_deeper
\begin_layout Standard
El código adicional para el operador 
\family typewriter
XOR
\family default
 también se debe pasar como argumento de línea de comandos al programa.
 Es decir, suponiendo que el ejecutable se llame 
\family typewriter
prog
\family default
, la línea de comando para ejecutar el programa tendría el formato: 
\begin_inset listings
lstparams "language=bash"
inline true
status open

\begin_layout Plain Layout

./prog <código> <cadena a codificar>
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Por ejemplo, se podría hacer 
\begin_inset listings
lstparams "language=bash"
inline true
status open

\begin_layout Plain Layout

./prog 12 Mensaje
\end_layout

\end_inset

 para codificar la cadena 
\begin_inset Quotes fld
\end_inset

Mensaje
\begin_inset Quotes frd
\end_inset

 con el código 12.
 Pruebe el programa codificando con diferentes códigos, por ejemplo, utilizando
 el código -98.
\end_layout

\begin_layout Standard
¿Qué modificaciones se tendrían que hacer al programa para que decodifique?
 ¿Se gana algo codificando más de una vez?
\end_layout

\begin_layout Paragraph
Solución
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>  // putchar
\end_layout

\begin_layout Plain Layout

#include <stdlib.h> // atoi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char** argv) {
\end_layout

\begin_layout Plain Layout

    for (int i = 0; argv[2][i]; i++)
\end_layout

\begin_layout Plain Layout

        putchar(atoi(argv[1]) ^ argv[2][i]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
No es necesario modificar el programa para decodificar pues
\begin_inset Formula 
\[
\left(m\oplus a\right)\oplus a=m\oplus\left(a\oplus a\right)=m\oplus0=m
\]

\end_inset


\end_layout

\begin_layout Standard
No se gana nada codificando varias veces pues 
\begin_inset Formula 
\[
\left(m\oplus a\right)\oplus b=m\oplus\left(a\oplus b\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Algoritmo del campesino ruso: La multiplicación de enteros positivos puede
 implementarse con sumas, el operador 
\family typewriter
AND
\family default
 y desplazamientos de bits usando las siguientes identidades:
\begin_inset Formula 
\[
a\cdot b\begin{cases}
0 & \text{si }b=0\\
a & \text{si }b=1\\
2a\cdot k & \text{si }b=2k\\
2a\cdot k+a & \text{si }b=2k+1
\end{cases}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Úselas para implementar una función 
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

unsigned mult(unsigned a, unsigned b);
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Solución
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

unsigned mult(unsigned a, unsigned b) {
\end_layout

\begin_layout Plain Layout

    if (!b) return 0;                              // b == 0
\end_layout

\begin_layout Plain Layout

    if (b == 1) return a;                          // b == 1
\end_layout

\begin_layout Plain Layout

    if (!(b & 1)) return mult((a << 1), (b >> 1)); // b par
\end_layout

\begin_layout Plain Layout

    return mult((a << 1), (b >> 1)) + a;           // b impar
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Muchas arquitecturas de CPU restringen los enteros a un máximo de 64 bits.
 ¿Qué sucede si ese rango no nos alcanza? Una solución es extender el rango
 utilizando más de un entero (en este caso enteros de 16 bits) para representar
 un valor.
 Así podemos pensar que:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

typedef struct {
\end_layout

\begin_layout Plain Layout

    unsigned short n[16];
\end_layout

\begin_layout Plain Layout

} nro;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
representa el valor:
\begin_inset Formula 
\[
\begin{aligned}N= & \texttt{ nro.n[0]} & +\\
 & \texttt{ nro.n[1] * (2\mathcircumflex sizeof(short) * 8)} & +\\
 & \texttt{ nro.n[1] * (2\mathcircumflex(2 * sizeof(short) * 8))} & +\\
 &  & \vdots\\
 & \texttt{ nro.n[15] * (2\mathcircumflex(15 * sizeof(short) * 8))}
\end{aligned}
\]

\end_inset


\end_layout

\begin_layout Standard
Podemos pensar en la estructura 
\family typewriter
nro
\family default
 como un entero de 256 bits.
 Lamentablemente la arquitectura no soporta operaciones entre valores de
 este tipo, por lo cual debemos realizarlas en software.
\end_layout

\begin_layout Enumerate
Implemente funciones que comparen con 0 y con 1 y determinen paridad para
 valores de este tipo.
\end_layout

\begin_layout Enumerate
Realice funciones que corran a izquierda y derecha los valores del tipo
 
\family typewriter
nro
\family default
.
\end_layout

\begin_layout Enumerate
Implemente la suma de valores del tipo 
\family typewriter
nro
\family default
.
\end_layout

\begin_layout Paragraph
Nota:
\end_layout

\begin_layout Standard
en el repositorio Subversion de la materia hay una función para imprimir
 valores de este tipo.
 Esta función utiliza la biblioteca GMP (
\emph on
GNU Multiple Precision Arithmetic Library
\emph default
), por lo cual deberá compilar el código agregando la opción 
\family typewriter
-lgmp
\family default
.
 Puede encontrar la función en el archivo 
\family typewriter
código/enteros/grandes/gmp1.c
\family default
: 
\begin_inset CommandInset href
LatexCommand href
target "https://svn.dcc.fceia.unr.edu.ar/svn/lcc/R-222/Public/código/enteros_grandes/gmp1.c"
literal "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Soluciones
\end_layout

\begin_layout Enumerate
\begin_inset space ~
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

int es_cero(nro n) {
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < 16; i++)
\end_layout

\begin_layout Plain Layout

        if (n.n[i]) return 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int es_uno(nro n) {
\end_layout

\begin_layout Plain Layout

    for (int i = 1; i < 16; i++)
\end_layout

\begin_layout Plain Layout

        if (n.n[i]) return 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return n.n[0] == 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int es_par(nro n) {
\end_layout

\begin_layout Plain Layout

    return (!(n.n[0] & 1));
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
COMPLETAR.
\end_layout

\begin_layout Enumerate
\begin_inset space ~
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

nro suc(nro n) {
\end_layout

\begin_layout Plain Layout

    nro s = n;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < 16; i++) {
\end_layout

\begin_layout Plain Layout

        s.n[i] += 1;
\end_layout

\begin_layout Plain Layout

        if ((int) n.n[i] + 1 == s.n[i]) return s;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return s;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

nro pred(nro n) {
\end_layout

\begin_layout Plain Layout

    nro p = n;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < 16; i++) {
\end_layout

\begin_layout Plain Layout

        p.n[i] -= 1;
\end_layout

\begin_layout Plain Layout

        if ((int) n.n[i] - 1 == p.n[i]) return p;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return p;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

nro add(nro a, nro b) {
\end_layout

\begin_layout Plain Layout

    if (es_cero(b)) return a;
\end_layout

\begin_layout Plain Layout

    return add(suc(a), pred(b));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Implemente el algoritmo del campesino ruso para los números anteriores.
\end_layout

\begin_deeper
\begin_layout Paragraph
Solución
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

nro mult(nro a, nro b) {
\end_layout

\begin_layout Plain Layout

	if (es_cero(b)) return b;
\end_layout

\begin_layout Plain Layout

	if (es_uno(b)) return a;
\end_layout

\begin_layout Plain Layout

	if (es_par(b)) return mult(izq(a, 1), der(b, 1));
\end_layout

\begin_layout Plain Layout

	return add(mult(izq(a), der(b)), a);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_body
\end_document
