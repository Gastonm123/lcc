#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language spanish-mexico
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Enumerate
Las listas finitas pueden especificarse como un TAD con los constructores:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

: Construye una lista vacía.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Cons
\end_layout

\end_inset

: Agrega un elemento a la lista.
\end_layout

\begin_layout Standard
y las siguientes operaciones:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

: Nos dice si la lista es vacía o no.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

head
\end_layout

\end_inset

: Devuelve el primer elemento de la lista.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

tail
\end_layout

\end_inset

: Devuelve todos los elementos de la lista menos el primero.
\end_layout

\begin_layout Enumerate
Dar una especificación algebraica del TAD listas finitas.
\end_layout

\begin_layout Enumerate
Dar una especificación tomando como modelo las secuencias.
\end_layout

\begin_layout Enumerate
Asumiendo que 
\begin_inset Formula $a$
\end_inset

 es un tipo con igualdad, especificar una función 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

inL :: List a -> a -> Bool
\end_layout

\end_inset

 tal que 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

inL xs x
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset

 si y solo si
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 x
\end_layout

\end_inset

 es un elemento de
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 xs
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Especificar una función que elimina todas las ocurrencias de un elemento
 dado.
\end_layout

\begin_layout Paragraph
Soluciones
\end_layout

\begin_layout Enumerate
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TAD 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

List (a :: Set)
\end_layout

\end_inset

 where
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

import Bool
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Nil :: List a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Cons :: a -> List a -> List a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

null :: List a -> Bool
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

head :: List a -> a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

tail :: List a -> List a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

null Nil
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

null (Cons x xs)
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

False
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

head (Cons x xs)
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

tail (Cons x xs)
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 xs
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left\langle \right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Cons (
\end_layout

\end_inset


\begin_inset Formula $x$
\end_inset

 
\begin_inset Formula $\left\langle x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left\langle x,x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

null 
\end_layout

\end_inset

 
\begin_inset Formula $\left\langle x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset

 (si 
\begin_inset Formula $n=0$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

False
\end_layout

\end_inset

 (si 
\begin_inset Formula $n>0$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

head 
\end_layout

\end_inset

 
\begin_inset Formula $\left\langle x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $x_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

tail 
\end_layout

\end_inset

 
\begin_inset Formula $\left\langle x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left\langle x_{2},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

inL Nil x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

False
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

inL (Cons x xs) y
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

if x == y then True else inL xs y
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

delete Nil x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

delete (Cons x xs) y
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

if x == y then delete xs y
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

            else Cons x (delete xs y)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Dado el TAD pilas, con las siguientes operaciones:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Empty
\end_layout

\end_inset

: Construye una pila inicialmente vacía.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Push
\end_layout

\end_inset

: Agrega un elemento al tope de la pila.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

isEmpty
\end_layout

\end_inset

: Devuelve verdadero si su argumento es una pila vacía, falso en caso contrario.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

top
\end_layout

\end_inset

: Devuelve el elemento que se encuentra al tope de la pila.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

pop
\end_layout

\end_inset

: Saca el elemento que se encuentra al tope de la pila.
\end_layout

\begin_layout Standard
Dar una especificación algebraica del TAD pilas y una especificación tomando
 como modelo las secuencias.
\end_layout

\begin_layout Paragraph
Soluciones
\end_layout

\begin_layout Itemize
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TAD 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Stack (a :: Set)
\end_layout

\end_inset

 where
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

import Bool
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Empty :: Stack a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Push :: a -> Stack a -> Stack a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

isEmpty :: Stack a -> Bool
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

top :: Stack a -> a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

pop :: Stack a -> Stack a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

isEmpty Empty
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

isEmpty (Push x xs)
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

False
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

top (Push x xs)
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

pop (Push x xs)
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 xs
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Empty
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left\langle \right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Push (
\end_layout

\end_inset


\begin_inset Formula $x$
\end_inset

 
\begin_inset Formula $\left\langle x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left\langle x,x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

isEmpty 
\end_layout

\end_inset

 
\begin_inset Formula $\left\langle x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

False
\end_layout

\end_inset

 (si 
\begin_inset Formula $n>0$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset

 (si 
\begin_inset Formula $n=0$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

top 
\end_layout

\end_inset

 
\begin_inset Formula $\left\langle x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $x_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

pop 
\end_layout

\end_inset

 
\begin_inset Formula $\left\langle x_{1},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left\langle x_{2},\ldots,x_{n}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Asumiendo que 
\begin_inset Formula $a$
\end_inset

 es un tipo con igualdad, completar la siguiente especificación algebraica
 del TAD conjunto.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TAD 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Conjunto (a :: Set)
\end_layout

\end_inset

 where
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

import Bool
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Vacio :: Conjunto a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Insertar :: a -> Conjunto a -> Conjunto a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

borrar :: a -> Conjunto a -> Conjunto a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

esVacio :: Conjunto a -> Bool
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

union :: Conjunto a -> Conjunto a -> Conjunto a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

interseccion :: Conjunto a -> Conjunto a -> Conjunto a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

resta :: Conjunto a -> Conjunto a -> Conjunto a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
¿Que pasaría si se agregase una función 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

choose :: Conjunto a -> a
\end_layout

\end_inset

, tal que 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

choose (insertar x c)
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 x
\end_layout

\end_inset

?
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Paragraph
Solución
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="20" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

insertar x (insertar y c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

insertar y (insertar x c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

insertar x (insertar x c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

insertar x c
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

borrar x Vacio
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Vacio
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

borrar x (insertar y c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

if x == y
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

  then borrar x c
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

  else insertar y (borrar x c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

esVacio Vacio
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

esVacio (insertar x xs)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

False
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

union c Vacio
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 c
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

union c (insertar x c')
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

union (insertar x c) c'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

in x Vacio
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

False
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

in x (insertar y c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

if x == y then True
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

            else in x c
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

interseccion c Vacio
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Vacio
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

interseccion c (insertar x c')
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

if x in c
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

  then insertar x (interseccion c c')
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

  else interseccion c c'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

resta c Vacio
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 c
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

resta c (insertar x c')
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

resta (borrar x c) c'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

inL (Cons x xs) y
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

if x == y then True else inL xs y
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
El TAD 
\emph on
priority queue
\emph default
 es una cola en la cual cada elemento tiene asociado un valor que es su
 prioridad (a dos elementos distintos le corresponden prioridades distintas).
 Los valores que definen la prioridad de los elementos pertenecen a un conjunto
 ordenado.
 Las siguientes son las operaciones soportadas por este TAD:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{samepage}
\end_layout

\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Vacia
\end_layout

\end_inset

: Construye una priority queue vacía.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Poner
\end_layout

\end_inset

: Agrega un elemento a una priority queue con una prioridad dada.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

primero
\end_layout

\end_inset

: Devuelve el elemento con mayor prioridad de una priority queue.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

sacar
\end_layout

\end_inset

: Elimina de una priority queue el elemento con mayor prioridad.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

esVacia
\end_layout

\end_inset

: Determina si una priority queue es vacía.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

union
\end_layout

\end_inset

: Une dos priority queues.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{samepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dar una especificación algebraica del TAD priority queue y una especificación
 tomando como modelo los conjuntos.
\end_layout

\begin_layout Paragraph
Soluciones
\end_layout

\begin_layout Itemize
\begin_inset Tabular
<lyxtabular version="3" rows="22" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TAD 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

PQueue (a :: Set)
\end_layout

\end_inset

 where
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

import Bool, Nat
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Vacia :: PQueue a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Poner :: a -> Nat -> PQueue a -> PQueue a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

primero :: PQueue a -> a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

sacar :: PQueue a -> PQueue a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

esVacia :: PQueue a -> Bool
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

union :: PQueue a -> PQueue a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

poner x p (poner y p c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

poner x p c
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

poner x p (poner y q c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

poner y q (poner x p c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

primero (Poner x p Vacia)
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

primero (Poner x p (Poner y q c))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

if p > q
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

  then primero (Poner x p c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

  else primero (Poner y q c)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

sacar (Poner x p Vacia)
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Vacia
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

sacar (Poner x p (Poner y q c))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

if p > q
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

then Poner y q (sacar (Poner x p c))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

else Poner x p (sacar (Poner y q c))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

esVacia Vacia
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

esVacia (Poner x p c)
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

False
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

union Vacia q
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

union (Poner x p c) q
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Poner x p (union c q)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Vacia
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left\{ \right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Poner (
\end_layout

\end_inset


\begin_inset Formula $x$
\end_inset

 
\begin_inset Formula $p$
\end_inset

 
\begin_inset Formula $C$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left\{ \left(x,p\right)\right\} \cup\left\{ \left(a,b\right)\in C/b\neq p\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

primero
\end_layout

\end_inset

 
\begin_inset Formula $C=\left\{ \left(x_{1},p_{1}\right),\ldots,\left(x_{n},p_{n}\right)\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left(x_{i},p_{i}\right)$
\end_inset

 donde 
\begin_inset Formula $p_{i}=\max\left\{ p_{1},\ldots,p_{n}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

sacar
\end_layout

\end_inset

 
\begin_inset Formula $C=\left\{ \left(x_{1},p_{1}\right),\ldots,\left(x_{n},p_{n}\right)\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $\left\{ \left(x_{i},p_{i}\right)\in C/p_{i}\neq\max\left\{ p_{1},\ldots,p_{n}\right\} \right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

esVacia
\end_layout

\end_inset

 
\begin_inset Formula $\left\{ \left(x_{1},p_{1}\right),\ldots,\left(x_{n},p_{n}\right)\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

False
\end_layout

\end_inset

 (si 
\begin_inset Formula $n>0$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset

 (si 
\begin_inset Formula $n=0$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

union
\end_layout

\end_inset

 
\begin_inset Formula $A=\left\{ \left(a_{1},b_{1}\right),\ldots,\left(a_{n},b_{n}\right)\right\} $
\end_inset

 
\begin_inset Formula $B$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset Formula $A\cup\left\{ \left(x,y\right)\in B/y\notin\left\{ b_{1},\ldots,b_{n}\right\} \right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Agregar a la siguiente definición del TAD árboles balanceados, una especificació
n para las operaciones 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 y 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

expose
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TAD 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

BalT (a :: Ordered Set)
\end_layout

\end_inset

 where
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

import Maybe, Nat, Tupla2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Empty :: BalT a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

join :: BalT a -> Maybe a -> BalT a -> BalT a
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size :: BalT a -> Nat
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

expose :: BalT a -> Maybe (BalT a, a, BalT a)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
La operación 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

join
\end_layout

\end_inset

 toma un árbol
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 l
\end_layout

\end_inset

, un elemento opcional y un árbol
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 r
\end_layout

\end_inset

.
 Si
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 l
\end_layout

\end_inset

 y
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 r
\end_layout

\end_inset

 son árboles de búsqueda balanceados tales que todos los elementos de
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 l
\end_layout

\end_inset

 sean menores que todos los elementos de
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 r
\end_layout

\end_inset

 y el elemento opcional es más grande que los de
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 l
\end_layout

\end_inset

 y menor que los de
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 r
\end_layout

\end_inset

, entonces 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

join
\end_layout

\end_inset

 crea un nuevo árbol de búsqueda balanceado.
\end_layout

\begin_layout Itemize
Las operaciones 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Empty
\end_layout

\end_inset

 y 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 son obvias.
\end_layout

\begin_layout Itemize
La operación 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

expose
\end_layout

\end_inset

 toma un árbol
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 t
\end_layout

\end_inset

 y nos da 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 si el árbol está vacío, y en otro caso nos devuelve un árbol izquierdo,
 un elemento raíz y un árbol derecho de un árbol de búsqueda que contiene
 todos los elementos de
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 t
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Notar que 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

join
\end_layout

\end_inset

 no es simplemente un constructor sino que tiene que realizar cierto trabajo
 para devolver un árbol balanceado.
 Debido a esto es conveniente especificar 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

expose
\end_layout

\end_inset

 por casos sobre su resultado.
\end_layout

\begin_layout Paragraph
Solución
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size Empty
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size (join l Nothing r)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size l + size r
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size (join l (Just x) r)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size l + size r + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

expose t
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

case (expose t) of
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

  Nothing -> t = Empty
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

  Just (l, x, r) -> t = join l (Just x) r
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Demostrar que 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

(uncurry zip) .
 unzip
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

, siendo:
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

zip :: [a] -> [b] -> [(a,b)]
\end_layout

\begin_layout Plain Layout

zip [] ys         = []
\end_layout

\begin_layout Plain Layout

zip (x:xs) []     = []
\end_layout

\begin_layout Plain Layout

zip (x:xs) (y:ys) = (x,y) : zip xs ys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unzip :: [(a,b)] -> ([a], [b])
\end_layout

\begin_layout Plain Layout

unzip []         = ([], [])
\end_layout

\begin_layout Plain Layout

unzip ((x,y):ps) = (x:xs, y:ys)
\end_layout

\begin_layout Plain Layout

                   where (xs,ys) = unzip ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uncurry :: (a -> b -> c) -> ((a,b) -> c)
\end_layout

\begin_layout Plain Layout

uncurry f p = f (fst p) (snd p)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(.) :: (b -> c) -> (a -> b) -> a -> c
\end_layout

\begin_layout Plain Layout

(.) f = 
\backslash
p -> f (fst p) (snd p)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Paragraph
Solución
\end_layout

\begin_layout Itemize
Caso base 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

[]
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

((uncurry zip) .
 unzip) []
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(uncurry zip) (unzip [])
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.unzip.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(uncurry zip) ([], [])
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.uncurry\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

zip (fst ([], [])) (snd ([], []))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.fst;def.snd\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

zip [] []
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.zip.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

[]
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.id\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

id []
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Caso inductivo 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

(x,y):ps
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

((uncurry zip) .
 unzip) ((x,y):ps)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(uncurry zip) (unzip ((x,y):ps))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.unzip.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(uncurry zip) (x:xs, y:ys) where (xs, ys) = unzip ps
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.uncurry;def.fst;def.snd\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

zip (x:xs) (y:ys) where (xs, ys) = unzip ps
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.zip.3;def.where\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(x,y) : zip (unzip ps)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ;H.I.;def.id\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(x,y):ps
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.id\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

id ((x,y):ps)
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Demostrar que 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

sum xs
\end_layout

\end_inset

 
\begin_inset Formula $\leq$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

length xs
\end_layout

\end_inset

 
\begin_inset Formula $*$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

maxl xs
\end_layout

\end_inset

, sabiendo que
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 xs
\end_layout

\end_inset

 es una lista de números naturales y que 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

maxl
\end_layout

\end_inset

 y 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 se definen como:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maxl :: Ord a => [a] -> a
\end_layout

\begin_layout Plain Layout

maxl []     = 0
\end_layout

\begin_layout Plain Layout

maxl (x:xs) = x `max` maxl xs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sum :: Num a => [a] -> a
\end_layout

\begin_layout Plain Layout

sum []     = 0
\end_layout

\begin_layout Plain Layout

sum (x:xs) = x + sum xs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

length :: [a] -> Int
\end_layout

\begin_layout Plain Layout

length []     = 0
\end_layout

\begin_layout Plain Layout

length (x:xs) = 1 + length xs
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Paragraph
Solución
\end_layout

\begin_layout Itemize
Caso base 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

[]
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

sum []
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.sum.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.*\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

0 * 0
\end_layout

\end_inset


\begin_inset Formula $\leq\left\langle prop.\leq\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

0 * 0
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.length.1;def.maxl.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

length [] * maxl []
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Caso inductivo
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 x:xs
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

sum (x:xs)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.sum.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

x + sum xs
\end_layout

\end_inset


\begin_inset Formula $\leq\left\langle H.I.\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

x + (length xs * maxl xs)
\end_layout

\end_inset


\begin_inset Formula $\leq$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

x + (x `max` maxl xs) * (length xs)
\end_layout

\end_inset


\begin_inset Formula $\leq$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(x `max` maxl xs) + (x `max` maxl xs) * (length xs)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle prop.*\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(1 + length xs) * (x `max` maxl xs)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.length.2+def.maxl.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

length (x:xs) * maxl (x:xs)
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Dado el siguiente tipo de datos: 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

data Arbol a = Hoja a | Nodo a (Arbol a) (Arbol a)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Dar el tipo y definir la función 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 que calcula la cantidad de elementos que contiene un 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Arbol a
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Demostrar la validez de la siguiente propiedad: 
\begin_inset Formula $\forall t\in$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

(Arbol a)
\end_layout

\end_inset

 
\begin_inset Formula $\exists k\in\mathbb{N}/$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 
\begin_inset Formula $t=2k+1$
\end_inset

.
\end_layout

\begin_layout Enumerate
Dar el tipo y definir la función 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

mirror
\end_layout

\end_inset

 que dado un árbol devuelve su árbol espejo.
\end_layout

\begin_layout Enumerate
Demostrar la validez de la siguiente propiedad: 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

(mirror .
 mirror)
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Considerando las siguientes funciones:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

hojas :: Arbol a -> Int
\end_layout

\begin_layout Plain Layout

hojas (Hoja x)       = 1
\end_layout

\begin_layout Plain Layout

hojas (Nodo x t1 t2) = hojas t1 + hojas t2
\end_layout

\begin_layout Plain Layout

altura :: Arbol a -> Int
\end_layout

\begin_layout Plain Layout

altura (Hoja x)       = 1
\end_layout

\begin_layout Plain Layout

altura (Nodo x t1 t2) = 1 + (altura t1 `max` altura t2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Demostrar que para todo árbol finito
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 t
\end_layout

\end_inset

 se cumple que 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

hojas t
\end_layout

\end_inset

 
\begin_inset Formula $<$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

2 ^ (altura t)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Paragraph
Soluciones
\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

size :: Arbol a -> Int
\end_layout

\begin_layout Plain Layout

size (Hoja _)     = 1
\end_layout

\begin_layout Plain Layout

size (Nodo _ l r) = 1 + size l + size r
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset space ~
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Caso base 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Hoja x
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

size (Hoja x)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.size.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle k=0\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

2k + 1
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Caso inductivo 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Nodo x l r
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

size (Nodo _ l r)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.size.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

1 + size l + size r
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle H.I.\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

1 + (2k'+1) + (2k''+1)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle k=k'+k''+1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

2k+1
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

mirror :: Arbol a -> Arbol a
\end_layout

\begin_layout Plain Layout

mirror (Hoja x)     = Hoja x
\end_layout

\begin_layout Plain Layout

mirror (Nodo x l r) = Nodo x (mirror r) (mirror l)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset space ~
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Caso base 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Hoja x
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(mirror .
 mirror) (Hoja x)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

mirror (mirror (Hoja x))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.mirror.1;def.mirror.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

Hoja x
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.id\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

id (Hoja x)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{samepage}
\end_layout

\end_inset

Caso inductivo 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Nodo x l r
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(mirror .
 mirror) Nodo x l r
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

mirror (mirror (Nodo x l r))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.mirror.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

mirror (Nodo x (mirror r) (mirror l))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.mirror.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

Nodo x (mirror (mirror l)) (mirror (mirror r))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

Nodo x ((mirror .
 mirror) l) ((mirror .
 mirror) r)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle H.I.;def.id\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

Nodo x l r
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.id\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

id (Nodo x l r)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{samepage}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset space ~
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Caso base 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Hoja x
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

hojas (Hoja x)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.hojas.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset


\begin_inset Formula $<$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

2^1
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.altura.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

2^(altura (Hoja x))
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Caso inductivo 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Nodo x l r
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

hojas (Nodo x l r)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.hojas.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

hojas l + hojas r
\end_layout

\end_inset


\begin_inset Formula $<\left\langle H.I.\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

2^(altura l) + 2^(altura r)
\end_layout

\end_inset


\begin_inset Formula $<$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

2 * 2^(altura l `max` altura r)
\end_layout

\end_inset


\begin_inset Formula $\equiv$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

2^(1 + (altura l `max` altura r))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.altura.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

2^(altura (Nodo x l r))
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
Dadas las siguientes definiciones:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

data AGTree a = Node a [AGTree a]
\end_layout

\begin_layout Plain Layout

ponerProfs n (Node x xs) = Node n (map (ponerProfs (n+1)) xs)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Definir una función 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

alturaAGT
\end_layout

\end_inset

 que calcule la altura de un 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

AGTree
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Definir una función 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

maxAGT
\end_layout

\end_inset

 que dado un 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

AGTree
\end_layout

\end_inset

 de enteros devuelva su mayor elemento.
\end_layout

\begin_layout Enumerate
Demostrar que 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

maxAGT .
 (ponerProfs 1)
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

alturaAGT
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Soluciones
\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

alturaAGT (Node _ []) = 1
\end_layout

\begin_layout Plain Layout

alturaAGT (Node _ xs) = 1 + maximum (map alturaAGT xs)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maxAGT (Node x []) = x
\end_layout

\begin_layout Plain Layout

maxAGT (Node x xs) = maximum (x:(map maxAGT xs))
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset space ~
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Caso base 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Node x []
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(maxAGT .
 (ponerProfs 1)) Node x []
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ;def.ponerProfs\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maxAGT (Node 1 (map (ponerProfs 2) []))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.map.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maxAGT (Node 1 [])
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.maxAGT.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.alturaAGT.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

alturaAGT (Node x [])
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Lema 1 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

ponerProfs (n+1)
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

mapT (+1) .
 ponerProfs n
\end_layout

\end_inset

: COMPLETAR.
\end_layout

\begin_layout Itemize
Lema 2 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

maxAGT .
 mapT (+1)
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

(+1) .
 maxAGT
\end_layout

\end_inset

: COMPLETAR.
\end_layout

\begin_layout Itemize
Lema 3 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

alturaAGT t
\end_layout

\end_inset

 
\begin_inset Formula $\geq$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

: COMPLETAR.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Caso inductivo 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Node x xs
\end_layout

\end_inset

:
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(maxAGT .
 (ponerProfs 1)) (Node x xs)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ;def.ponerProfs.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maxAGT (Node 1 (map (ponerProfs 2) xs))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.maxAGT.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maximum (1:(map maxAGT (map (ponerProfs 2) xs)))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle prop.map\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maximum (1:(map (maxAGT .
 (ponerProfs 2)) xs))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle lema.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maximum (1:(map (maxAGT .
 mapT (+1) .
 ponerProfs 1) xs))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle lema.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maximum (1:(map ((+1) .
 maxAGT .
 ponerProfs 1) xs))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle prop.map\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maximum (1:(map (+1) (map (maxAGT.
 ponerProfs 1) xs)))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.map;H.I.\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maximum (1:(map (+1) (map alturaAGT xs)))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle lema.3\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

maximum (map (+1) (map alturaAGT xs))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle prop\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

1 + maximum (map alturaAGT xs)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.alturaAGT.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

alturaAGT (Node x xs)
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Dadas las siguientes definiciones:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

data Tree a = Leaf a | Node a (Tree a) (Tree a)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

flatten (Leaf x)     = [x]
\end_layout

\begin_layout Plain Layout

flatten (Node x l r) = flatten l ++ [x] ++ flatten r
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mapTree f (Leaf x)     = Leaf (f x)
\end_layout

\begin_layout Plain Layout

mapTree f (Node x l r) = Node (f x) (mapTree f l) (mapTree f r)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
demostrar que 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

(map f) .
 flatten
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

flatten .
 (mapTree f)
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Solución
\end_layout

\begin_layout Itemize
Caso base 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Leaf x
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

((map f) .
 flaten) (Leaf x)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

map f (flaten (Leaf x))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.flatten.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

map f (x:[])
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.map.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(f x) : (map f [])
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.map.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(f x) : []
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.flatten.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

flatten (Leaf (f x))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.mapTree.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

flatten (mapTree f (Leaf x))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(flatten .
 (mapTree f)) (Leaf x)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Caso inductivo 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Node x l r
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{samepage}
\end_layout

\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

((map f) .
 flaten) (Node x l r)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ;def.flatten.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

map f (flaten l ++ [x] ++ flatten r)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle prop.map\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

map f (flaten l) ++ map f [x] ++ map f (flatten r)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ;H.I.\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(flatten .
 (mapTree f)) l ++ map f [x] ++ (flatten .
 (mapTree f)) r
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.flatten.2;def.map;def.\circ\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

flatten (Node (f x) (mapTree f l) (mapTree f r))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.\circ;def.mapTree.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

(flatten .
 (mapTree f)) (Node x l r)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{samepage}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Dada la siguiente definición,
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

join []       = xs
\end_layout

\begin_layout Plain Layout

join (xs:xss) = xs ++ join xss
\end_layout

\end_inset

demostrar:
\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

join
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

concat .
 (map id)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

join .
 join
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

join .
 (map join)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Soluciones
\end_layout

\begin_layout Enumerate
COMPLETAR.
\end_layout

\begin_layout Enumerate
COMPLETAR.
\end_layout

\end_deeper
\begin_layout Enumerate
Dadas las funciones 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

insert :: Ord a => a -> Bin a -> Bin a
\end_layout

\end_inset

, que agrega un elemento a un 
\begin_inset Formula $BST$
\end_inset

 dado, y 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

inorder :: Ord a => Bin a -> [a]
\end_layout

\end_inset

, que realiza un recorrido 
\begin_inset Formula $inorder$
\end_inset

 sobre un 
\begin_inset Formula $BST$
\end_inset

, dadas en clase de teoría, probar las siguientes propiedades sobre las
 funciones:
\end_layout

\begin_deeper
\begin_layout Enumerate
Si 
\begin_inset Formula $t$
\end_inset

 es un 
\begin_inset Formula $BST$
\end_inset

, entonces 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

insert x t
\end_layout

\end_inset

 es un 
\begin_inset Formula $BST$
\end_inset

.
\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $t$
\end_inset

 es 
\begin_inset Formula $BST$
\end_inset

, entonces 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

inorder t
\end_layout

\end_inset

 es una lista ordenada.
\end_layout

\begin_layout Paragraph
Soluciones
\end_layout

\begin_layout Enumerate
COMPLETAR.
\end_layout

\begin_layout Enumerate
COMPLETAR.
\end_layout

\end_deeper
\begin_layout Enumerate
Dadas las definición de funciones que implementan 
\emph on
leftist heaps
\emph default
, dadas en clase, probar que si
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 h1
\end_layout

\end_inset

 y
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 h2
\end_layout

\end_inset

 son leftist heaps, entonces 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

merge h1 h2
\end_layout

\end_inset

 es un leftist heap.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_deeper
\begin_layout Paragraph
Solución
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

checkH E           = True
\end_layout

\begin_layout Plain Layout

checkH (N _ _ l r) = rank l >= rank r && checkH l && checkH r
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Lema: Si 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 h1
\end_layout

\end_inset

 y
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 h2
\end_layout

\end_inset

 son leftist heaps, entonces 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

check (makeH h1 h2)
\end_layout

\end_inset

 también lo es.
\end_layout

\begin_deeper
\begin_layout Itemize
Caso base 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

E
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

checkH (makeH x E h2)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.makeH\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell,fontsize={\footnotesize}"
inline false
status open

\begin_layout Plain Layout

checkH (if rank E >= rank h2 then N (rank h2 + 1) x E h2 else N (x + 1)
 x h2 h1)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.rank.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell,fontsize={\footnotesize}"
inline false
status open

\begin_layout Plain Layout

checkH (if 0 >= rank h2 then N (rank h2 + 1) x E h2 else N (rank E + 1)
 x h2 E)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Caso 
\begin_inset Formula $0\geq$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 rank h2
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\equiv\left\langle def.if\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

checkH (N (rank h2 + 1) x E h2)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.checkH.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

rank E >= rank h2 && checkH E && checkH h2
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.rank.1\land def.checkH.1\land Hipotesis\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

0 >= rank h2 && True && True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\equiv\left\langle caso.0\geq rank.h2\land def.\&\&\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Caso 
\begin_inset Formula $0<$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 rank h2
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\equiv\left\langle def.if\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

checkH (N (rank E + 1) x h2 E))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.checkH.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

rank h2 >= rank E && checkH h2 && checkH E
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.rank.1\land Hipotesis\land def.checkH.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

rank h2 >= 0 && True && True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\equiv\left\langle caso.0<rank.h2\land def.\&\&\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Caso inductivo 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

N x a1 b1
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

checkH (makeH x (N x a1 b1) h2)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.makeH+def.rank.2\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell,fontsize={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

checkH (if x >= rank h2 then N (y + 1) x (N x a1 b1) h2 else N (x + 1) x
 h2 (N x a1 b1))
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Caso 
\begin_inset Formula $x\geq$
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 rank h2
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

checkH (N (y + 1) x (N x a1 b1) h2)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.checkH.2+def.rank.1\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

x >= rank h2 && checkH (N x a1 b1) && checkH h2
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle x\geq rank.h2\land Hipotesis\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

True && checkH (N x a1 b1) && True
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.checkH\land H.I.\land def.\&\&\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Caso 
\begin_inset Formula $x<$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 rank h2
\end_layout

\end_inset

: COMPLETAR.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

checkH (merge h1 h2)
\end_layout

\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Caso base: COMPLETAR.
\end_layout

\begin_layout Itemize
Caso inductivo:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

checkH (merge h1 h2)
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle def.merge\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell,fontsize={\small}"
inline false
status open

\begin_layout Plain Layout

checkH (if x <= y makeH x a1 (merge b1 h2) else makeH y a2 (merge h1 b2))
\end_layout

\end_inset


\begin_inset Formula $\equiv\left\langle caso.x\leq y\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

checkH (makeH x a1 (merge b1 h2))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\equiv\left\langle H.I.\land Lema\right\rangle $
\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
Dar el principio de inducción estructural para el siguiente tipo de datos:
 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

data F = Zero | One F | Two (Bool -> F)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Paragraph
Solución
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $P$
\end_inset

 una propiedad definida sobre elementos de 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Itemize
Si 
\begin_inset Formula $P$
\end_inset

 vale en 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Zero
\end_layout

\end_inset

 y ademas;
\end_layout

\begin_layout Itemize
si 
\begin_inset Formula $P$
\end_inset

 vale en
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 f
\end_layout

\end_inset

 también vale en 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

One f
\end_layout

\end_inset

 y ademas;
\end_layout

\begin_layout Itemize
si para cualquier
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 g
\end_layout

\end_inset

, 
\begin_inset Formula $P$
\end_inset

 vale en
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 g True
\end_layout

\end_inset

 y
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

 g True
\end_layout

\end_inset

 entonces también vale en 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Two (g True)
\end_layout

\end_inset

 y 
\begin_inset listings
lstparams "language=Haskell"
inline true
status open

\begin_layout Plain Layout

Two (g False)
\end_layout

\end_inset

;
\end_layout

\begin_layout Standard
entonces 
\begin_inset Formula $P$
\end_inset

 vale para todos los elementos de 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\end_deeper
\end_body
\end_document
